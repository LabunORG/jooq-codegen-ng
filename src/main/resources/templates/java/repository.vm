package $package;

import org.jooq.Condition;
import org.jooq.DSLContext;
import org.jooq.Field;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.UniqueKey;

import javax.annotation.Generated;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * This class is generated by jooq-codegen-ng.
*/
@Generated({"jooq-codegen-ng:"})
@SuppressWarnings({"all", "unchecked", "rawtypes"})
public class $className {
    protected final $tableClassName table = $tableClassName.${table.name.toUpperCase()};
    protected final DSLContext jooq;
    private final Map<String, Field> pkFieldsMap;

    public $className(DSLContext dslContext) {
        this.jooq = dslContext;
        this.pkFieldsMap = getPKFieldsMap();
    }

    public boolean isFor(Table table) {
        return table != null && ${tableClassName}.class.isAssignableFrom(table.getClass());
    }

    public <RET> List<RET> findAll(Class<RET> clazz) {
        return jooq.selectFrom(table).fetchInto(clazz);
    }

    public int delete(Object entity) {
        Map<Field, Object> id = getId(entity);
        if (id.values().stream().anyMatch(it -> it == null))
            throw new IllegalStateException("Passed entity have not initialized id field(s)");

        return toRecord(entity).delete();
    }

    public int delete(Iterable<Object> entities) {
        if (entities == null) return 0;

        List<$recordClassName> records = StreamSupport.stream(entities.spliterator(), false)
                .map(it -> toRecord(it))
                .collect(Collectors.toList());

        int[] result = jooq.batchDelete(records).execute();
        return Arrays.stream(result).sum();
    }

    public void deleteAll() {
        jooq.delete(table).execute();
    }

    public long count() {
        return jooq.selectCount().from(table).fetchOne(0, Long.class);
    }

    public <T> T save(T entity) {
        $recordClassName record = toRecord(entity);
        record.store();
        return record.into(entity);
    }

    public <T> Iterable<T> save(Iterable<T> entities) {
        if (entities == null) return Collections.emptyList();

        List<$recordClassName> records = StreamSupport.stream(entities.spliterator(), false)
                .map(it -> toRecord(it))
                .collect(Collectors.toList());

        jooq.batchStore(records).execute();

        return applyRecordsToEntities(entities, records);
    }

    private $recordClassName toRecord(Object entity) {
        Map<Field, Object> id = getId(entity);
        if (id.values().stream().anyMatch(it -> it == null))
            return insertRecord(entity);
        return updateRecord(id, entity);
    }

    private $recordClassName updateRecord(Map<Field, Object> id, Object entity) {
        return fetchLockedById(id)
                .map(it -> applyFrom(it, entity))
                .orElse(null);
    }

    private $recordClassName applyFrom($recordClassName row, Object update) {
        row.from(update);
        return row;
    }

    private $recordClassName insertRecord(Object entity) {
        return jooq.newRecord(table, entity);
    }

    private Map<String, Field> getPKFieldsMap() {
        return table.getPrimaryKey().getFields().stream()
                .collect(Collectors.toMap(it -> toCamelCase(it.getName()), it -> it));
    }

    private Map<Field, Object> getId(Object entity) {
        return Stream.of(entity.getClass().getDeclaredFields())
                .filter(it -> pkFieldsMap.containsKey(it.getName()))
                .collect(Collectors.toMap(it -> pkFieldsMap.get(it.getName()), it -> getFieldValue(entity, it)));
    }

    private String toCamelCase(String src) {
        return Arrays.stream(src.split("_"))
                .map(String::toLowerCase)
                .map(it -> capitalize(it))
                .collect(Collectors.joining(""));
    }

    private static String capitalize(String src) {
        if (src.length() == 0) return src;
        return Character.toUpperCase(src.charAt(0)) + src.substring(1);
    }

    private <V> V getFieldValue(Object entity, java.lang.reflect.Field field) {
        try {
            field.setAccessible(true);
            return (V) field.get(entity);
        } catch (Exception e) {
            throw new RepositoryException(e);
        }
    }

    private <T> List<T> applyRecordsToEntities(Iterable<T> entities, List<$recordClassName> records) {
        List<T> result = new ArrayList<>();
        Iterator<T> entitiesIterator = entities.iterator();
        Iterator<$recordClassName> recordsIterator = records.iterator();
        while (entitiesIterator.hasNext() && recordsIterator.hasNext()) {
            $recordClassName record = recordsIterator.next();
            T entity = entitiesIterator.next();
            result.add(record.into(entity));
        }
        return result;
    }

    private List<TableField<$recordClassName, ?>> pk() {
        UniqueKey<$recordClassName> key = table.getPrimaryKey();
        if (key == null) throw new IllegalStateException("no pk found");
        return key.getFields();
    }

    protected Optional<$recordClassName> fetchById(Map<Field, Object> id) {
        return buildCondition(id)
                .map(condition ->
                        jooq.selectFrom(table)
                                .where()
                                .fetchOne());
    }

    private Optional<Condition> buildCondition(Map<Field, Object> id) {
        return id.entrySet().stream()
                .map(e -> e.getKey().eq(e.getValue()))
                .reduce(Condition::and);
    }

    protected Optional<$recordClassName> fetchLockedById(Map<Field, Object> id) {
        return buildCondition(id)
                .map(condition ->
                        jooq.selectFrom(table)
                                .where(condition)
                                .forUpdate()
                                .fetchOne());
    }

    public static class RepositoryException extends RuntimeException {
        public RepositoryException(Throwable cause) {
            super(cause);
        }
    }

#macro( forUpdate $needLock )
    #if( $needLock )
            .forUpdate()
    #end
#end
#macro( findByUniqKeyColumn $column $varName $needLock)
    #set( $action = ${util.conditional($needLock, "lock", "find")} )
    public <RET> Optional<RET> ${action}By${column.javaName}($column.javaType $varName, Class<RET> clazz) {
        RET result = jooq.selectFrom(table)
            .where(table.${column.name.toUpperCase()}.eq($varName))
    #forUpdate($needLock)
            .fetchOneInto(clazz);
        return Optional.ofNullable(result);
    }

#end
#macro( findByColumn $column $varName $needLock)
    #set( $action = ${util.conditional($needLock, "lock", "find")} )
    public <RET> List<RET> ${action}By${column.javaName}($column.javaType $varName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.${column.name.toUpperCase()}.eq($varName))
    #forUpdate($needLock)
            .fetchInto(clazz);
    }

#end
#macro( findByColumnIn $column $varName $needLock)
    #set( $action = ${util.conditional($needLock, "lock", "find")} )
    public <RET> List<RET> ${action}By${column.javaName}In(List<$column.javaType> $varName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.${column.name.toUpperCase()}.in($varName))
    #forUpdate($needLock)
            .fetchInto(clazz);
    }

#end
#foreach( $column in $columns )
    #set( $varName = ${util.decapitalize($column.javaName)} )
    #if ( ${util.isSearchable($column)} )
        #if ( $util.isUniqKey($uniqKeys, $column) )
            #findByUniqKeyColumn($column, $varName, false)
            #findByUniqKeyColumn($column, $varName, true)
        #else
            #findByColumn($column, $varName, false)
            #findByColumn($column, $varName, true)
        #end
        #findByColumnIn($column, $varName, false)
        #findByColumnIn($column, $varName, true)
    #end
#end
}
