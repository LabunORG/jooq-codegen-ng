package org.labun.jooq.generator.repository;

import org.jooq.Condition;
import org.jooq.DSLContext;
import org.jooq.Field;
import org.jooq.Table;
import org.jooq.TableField;
import org.jooq.UniqueKey;

import javax.annotation.Generated;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

/**
 * This class is generated by jooq-generator.
*/
@Generated({"jooq-generator:"})
@SuppressWarnings({"all", "unchecked", "rawtypes"})
public class PersonRepositoryBase {
    protected final org.labun.jooq.codegen.table.PersonTable table = org.labun.jooq.codegen.table.PersonTable.PERSON;
    protected final DSLContext jooq;
    private final Map<String, Field> pkFieldsMap;

    public PersonRepositoryBase(DSLContext dslContext) {
        this.jooq = dslContext;
        this.pkFieldsMap = getPKFieldsMap();
    }

    public boolean isFor(Table table) {
        return table != null && org.labun.jooq.codegen.table.PersonTable.class.isAssignableFrom(table.getClass());
    }

    public <RET> List<RET> findAll(Class<RET> clazz) {
        return jooq.selectFrom(table).fetchInto(clazz);
    }

    public int delete(Object entity) {
        Map<Field, Object> id = getId(entity);
        if (id.values().stream().anyMatch(it -> it == null))
            throw new IllegalStateException("Passed entity have not initialized id field(s)");

        return toRecord(entity).delete();
    }

    public int delete(Iterable<Object> entities) {
        if (entities == null) return 0;

        List<org.labun.jooq.codegen.record.PersonRecord> records = StreamSupport.stream(entities.spliterator(), false)
                .map(it -> toRecord(it))
                .collect(Collectors.toList());

        int[] result = jooq.batchDelete(records).execute();
        return Arrays.stream(result).sum();
    }

    public void deleteAll() {
        jooq.delete(table).execute();
    }

    public long count() {
        return jooq.selectCount().from(table).fetchOne(0, Long.class);
    }

    public <T> T save(T entity) {
        org.labun.jooq.codegen.record.PersonRecord record = toRecord(entity);
        record.store();
        return record.into(entity);
    }

    public <T> Iterable<T> save(Iterable<T> entities) {
        if (entities == null) return Collections.emptyList();

        List<org.labun.jooq.codegen.record.PersonRecord> records = StreamSupport.stream(entities.spliterator(), false)
                .map(it -> toRecord(it))
                .collect(Collectors.toList());

        jooq.batchStore(records).execute();

        return applyRecordsToEntities(entities, records);
    }

    private org.labun.jooq.codegen.record.PersonRecord toRecord(Object entity) {
        Map<Field, Object> id = getId(entity);
        if (id.values().stream().anyMatch(it -> it == null))
            return insertRecord(entity);
        return updateRecord(id, entity);
    }

    private org.labun.jooq.codegen.record.PersonRecord updateRecord(Map<Field, Object> id, Object entity) {
        return fetchLockedById(id)
                .map(it -> applyFrom(it, entity))
                .orElse(null);
    }

    private org.labun.jooq.codegen.record.PersonRecord applyFrom(org.labun.jooq.codegen.record.PersonRecord row, Object update) {
        row.from(update);
        return row;
    }

    private org.labun.jooq.codegen.record.PersonRecord insertRecord(Object entity) {
        return jooq.newRecord(table, entity);
    }

    private Map<String, Field> getPKFieldsMap() {
        return table.getPrimaryKey().getFields().stream()
                .collect(Collectors.toMap(it -> toCamelCase(it.getName()), it -> it));
    }

    private Map<Field, Object> getId(Object entity) {
        return Stream.of(entity.getClass().getDeclaredFields())
                .filter(it -> pkFieldsMap.containsKey(it.getName()))
                .collect(Collectors.toMap(it -> pkFieldsMap.get(it.getName()), it -> getFieldValue(entity, it)));
    }

    private String toCamelCase(String src) {
        return Arrays.stream(src.split("_"))
                .map(String::toLowerCase)
                .map(it -> capitalize(it))
                .collect(Collectors.joining(""));
    }

    private static String capitalize(String src) {
        if (src.length() == 0) return src;
        return Character.toUpperCase(src.charAt(0)) + src.substring(1);
    }

    private <V> V getFieldValue(Object entity, java.lang.reflect.Field field) {
        try {
            field.setAccessible(true);
            return (V) field.get(entity);
        } catch (Exception e) {
            throw new RepositoryException(e);
        }
    }

    private <T> List<T> applyRecordsToEntities(Iterable<T> entities, List<org.labun.jooq.codegen.record.PersonRecord> records) {
        List<T> result = new ArrayList<>();
        Iterator<T> entitiesIterator = entities.iterator();
        Iterator<org.labun.jooq.codegen.record.PersonRecord> recordsIterator = records.iterator();
        while (entitiesIterator.hasNext() && recordsIterator.hasNext()) {
            org.labun.jooq.codegen.record.PersonRecord record = recordsIterator.next();
            T entity = entitiesIterator.next();
            result.add(record.into(entity));
        }
        return result;
    }

    private List<TableField<org.labun.jooq.codegen.record.PersonRecord, ?>> pk() {
        UniqueKey<org.labun.jooq.codegen.record.PersonRecord> key = table.getPrimaryKey();
        if (key == null) throw new IllegalStateException("no pk found");
        return key.getFields();
    }

    protected Optional<org.labun.jooq.codegen.record.PersonRecord> fetchById(Map<Field, Object> id) {
        return buildCondition(id)
                .map(condition ->
                        jooq.selectFrom(table)
                                .where()
                                .fetchOne());
    }

    private Optional<Condition> buildCondition(Map<Field, Object> id) {
        return id.entrySet().stream()
                .map(e -> e.getKey().eq(e.getValue()))
                .reduce(Condition::and);
    }

    protected Optional<org.labun.jooq.codegen.record.PersonRecord> fetchLockedById(Map<Field, Object> id) {
        return buildCondition(id)
                .map(condition ->
                        jooq.selectFrom(table)
                                .where(condition)
                                .forUpdate()
                                .fetchOne());
    }

    public static class RepositoryException extends RuntimeException {
        public RepositoryException(Throwable cause) {
            super(cause);
        }
    }

    public <RET> Optional<RET> findById(java.lang.Long id, Class<RET> clazz) {
        RET result = jooq.selectFrom(table)
            .where(table.ID.eq(id))
            .fetchOneInto(clazz);
        return Optional.ofNullable(result);
    }

    public <RET> Optional<RET> lockById(java.lang.Long id, Class<RET> clazz) {
        RET result = jooq.selectFrom(table)
            .where(table.ID.eq(id))
            .forUpdate()
            .fetchOneInto(clazz);
        return Optional.ofNullable(result);
    }

    public <RET> List<RET> findByIdIn(List<java.lang.Long> id, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.ID.in(id))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByIdIn(List<java.lang.Long> id, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.ID.in(id))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByFirstName(java.lang.String firstName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.FIRST_NAME.eq(firstName))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByFirstName(java.lang.String firstName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.FIRST_NAME.eq(firstName))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByFirstNameIn(List<java.lang.String> firstName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.FIRST_NAME.in(firstName))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByFirstNameIn(List<java.lang.String> firstName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.FIRST_NAME.in(firstName))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByLastName(java.lang.String lastName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.LAST_NAME.eq(lastName))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByLastName(java.lang.String lastName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.LAST_NAME.eq(lastName))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByLastNameIn(List<java.lang.String> lastName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.LAST_NAME.in(lastName))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByLastNameIn(List<java.lang.String> lastName, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.LAST_NAME.in(lastName))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByAge(java.lang.Integer age, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.AGE.eq(age))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByAge(java.lang.Integer age, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.AGE.eq(age))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByAgeIn(List<java.lang.Integer> age, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.AGE.in(age))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByAgeIn(List<java.lang.Integer> age, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.AGE.in(age))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByBirthDate(java.time.LocalDate birthDate, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.BIRTH_DATE.eq(birthDate))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByBirthDate(java.time.LocalDate birthDate, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.BIRTH_DATE.eq(birthDate))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByBirthDateIn(List<java.time.LocalDate> birthDate, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.BIRTH_DATE.in(birthDate))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByBirthDateIn(List<java.time.LocalDate> birthDate, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.BIRTH_DATE.in(birthDate))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByCreated(java.time.LocalDateTime created, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.CREATED.eq(created))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByCreated(java.time.LocalDateTime created, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.CREATED.eq(created))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByCreatedIn(List<java.time.LocalDateTime> created, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.CREATED.in(created))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByCreatedIn(List<java.time.LocalDateTime> created, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.CREATED.in(created))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByLastModified(java.time.LocalDateTime lastModified, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.LAST_MODIFIED.eq(lastModified))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByLastModified(java.time.LocalDateTime lastModified, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.LAST_MODIFIED.eq(lastModified))
            .forUpdate()
            .fetchInto(clazz);
    }

    public <RET> List<RET> findByLastModifiedIn(List<java.time.LocalDateTime> lastModified, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.LAST_MODIFIED.in(lastModified))
            .fetchInto(clazz);
    }

    public <RET> List<RET> lockByLastModifiedIn(List<java.time.LocalDateTime> lastModified, Class<RET> clazz) {
        return jooq.selectFrom(table)
            .where(table.LAST_MODIFIED.in(lastModified))
            .forUpdate()
            .fetchInto(clazz);
    }

}
